FIBO(1)
FIBO(2)
FIBO(2)
FIBO(100)
FIBO(50)
FIBO(10)
FIBO(20)
for(i in 1:20){
FIBO(i)
}
for(i in 1:20){
FIBO(i) |> print()
}
FIBO(1)
A = FIBO(1)
A
# Mecanismo generador de fibonacci
FIBO = function(n){
# Crear una lista inicial con los valores F_0=1 y F_1 = 1
FV = c(1,1)
if(n>=2){
# Hacer el ciclo que la construya poco a poco
for(i in 3:(n+1) ){
# Desde el elemnto 3 hasta el elemento n, suma los 2 anteriores
FV[i] = FV[i-1] + FV[i-2]
}
# Nombrar los datos en orden
names(FV) = 0:(n)
FV[paste0(n)] |> as.numeric()
}else{
names(FV) = 0:1
FV[paste0(n-1)] |> as.numeric()
}
#Devolver el ultimo numero
}
FIBO(5)
#### Paso 2 ####
ban1 = 0
ban2 = 0
ban1 == 0 & ban2 == 0
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
#### Paso 2 ####
ban1 = 0
ban2 = 0
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Logica para evaluar una u otra
# Cuando es la primera evaluación
if(ban1 == 0 & ban2 == 0){
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
}else{
if(ban1 == 1){ # EVALUA EL DE LA DERECHA QUE SE ACTUALIZO
fx1 = fx(x1)
}else{ # EVALUA EL DE LA IZQUIERDA QUE SE ACTUALIZO
fx2 = fx(x2)
}
}
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
ban1 = 1
ban2 = 0
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
ban1 = 0
ban2 = 1
}
}
## Evaluar si K == N
k = k+1
}
# Devolver la función
return(c(a,b))
}
fibonacci(fx,0,5,10)
### Definir la función a evaluar
fx = function(x){(x^2) +  (54/x)}
a = 0
b = 5
N = 3
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
#### Paso 2 ####
ban1 = 0
ban2 = 0
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Logica para evaluar una u otra
# Cuando es la primera evaluación
if(ban1 == 0 & ban2 == 0){
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
}else{
if(ban1 == 1){ # EVALUA EL DE LA DERECHA QUE SE ACTUALIZO
fx1 = fx(x1)
}else{ # EVALUA EL DE LA IZQUIERDA QUE SE ACTUALIZO
fx2 = fx(x2)
}
}
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
ban1 = 1
ban2 = 0
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
ban1 = 0
ban2 = 1
}
}
## Evaluar si K == N
k = k+1
}
# Devolver la función
return(c(a,b))
}
fibonacci(fx,0,5,10)
fibonacci(fx,0,5,5)
fibonacci(fx,0,5,100)
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
#### Paso 2 ####
ban1 = 0
ban2 = 0
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Logica para evaluar una u otra
# Cuando es la primera evaluación
if(ban1 == 0 & ban2 == 0){
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
}else{
if(ban1 == 1){ # EVALUA EL DE LA DERECHA QUE SE ACTUALIZO
fx1 = fx(x1)
}else{ # EVALUA EL DE LA IZQUIERDA QUE SE ACTUALIZO
fx2 = fx(x2)
}
}
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
ban1 = 0
ban2 = 1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
ban1 = 1
ban2 = 0
}
}
## Evaluar si K == N
k = k+1
}
# Devolver la función
return(c(a,b))
}
fibonacci(fx,0,5,100)
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
#### Paso 2 ####
ban1 = 0
ban2 = 0
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
}
# Devolver la función
return(c(a,b))
}
fibonacci(fx,0,5,100)
fibonacci(fx,0,5,50)
fibonacci(fx,0,5,6)
fibonacci(fx,0,5,10)
rm(list = ls())
rm(list=ls())
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
fx = function(x){(x^2) +  (54/x)}
a = 0
b = 5
N = 3
fibonacci(fx,a,b,N)
# Tabla bonita para los resultados
resu = data.frame(k = 0, Lke = 0, a = 0, b = 0, x1 = 0, x2 = 0)
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
# Tabla bonita para los resultados
resu = data.frame(k = 0, Lke = 0, a = 0, b = 0, x1 = 0, x2 = 0)
#### Paso 2 ####
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
resu[k-2,] = data.frame(k, Lke, a, b , x1 , x2)
}
# Devolver la función
return(c(a,b),resu)
}
fibonacci(fx,a,b,N)
# Devolver la función
return(list(c(a,b),resu))
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
# Tabla bonita para los resultados
resu = data.frame(k = 0, Lke = 0, a = 0, b = 0, x1 = 0, x2 = 0)
#### Paso 2 ####
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
resu[k-2,] = data.frame(k, Lke, a, b , x1 , x2)
}
# Devolver la función
return(list(c(a,b),resu))
}
fibonacci(fx,a,b,N)
rm(list=ls())
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
fx = function(x){(x^2) +  (54/x)}
a = 0
b = 5
N = 3
fibonacci(fx,a,b,N)
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
# Tabla bonita para los resultados
resu = data.frame(iter = 0, a = 0, b = 0, fx1 = 0, fx2 = 0)
#### Paso 2 ####
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
resu[k-2,] = data.frame(iter = k, a, b , fx1 , fx2)
}
# Devolver la función
return(c(a,b))
return(resu))
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
# Tabla bonita para los resultados
resu = data.frame(iter = 0, a = 0, b = 0, fx1 = 0, fx2 = 0)
#### Paso 2 ####
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
resu[k-2,] = data.frame(iter = k, a, b , fx1 , fx2)
}
# Devolver la función
return(c(a,b))
return(resu)
}
fibonacci(fx,a,b,N)
fibonacci = function(fx,a,b,N){
#### Paso 1 ####
L = b-a;L # ESTO VA
k = 2 # ESTO VA FIJO
# Llevar el control interno
contador = 0
# Tabla bonita para los resultados
resu = data.frame(iter = 0, a = 0, b = 0, fx1 = 0, fx2 = 0)
#### Paso 2 ####
while(k<=N){
# Calcular la razon con numeros de fibonacci para la distancia
Lke = (FIBO(N-k+1)/FIBO(N+1))*L;Lke
x1 = a+Lke
x2 = b-Lke
#### Paso 3, eliminación de regiones ###
# Evalua ambaos lados
fx1 = fx(x1)
fx2 = fx(x2)
# Decidir que hacer si
if(fx1>fx2){ #Si fx1 es mayor a fx2, corta la izquierda
a = x1
} else{
if(fx1<fx2){ #Si fx1 es menor a fx2, corta la derecha
b = x2
}
}
## Evaluar si K == N
k = k+1
resu[k-2,] = data.frame(iter = k, a, b , fx1 , fx2)
}
# Devolver la función
return(resu)
}
fibonacci(fx,a,b,N)
knitr::opts_chunk$set(echo = F,
eval = F,
message = F,
warning = F)
# Librería para hacer las tablas bonitas
library(flextable)
# Llamo el código
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
# Declaro la función que se desea minimizar
fx = function(x){(x^2) +  (54/x)}
#Aplicar el método con los parámetros mencionados
res1 = round(fibonacci(fx,a,b,N),6)
res1
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
# Librería para hacer las tablas bonitas
library(flextable)
# Llamo el código
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
# Declaro la función que se desea minimizar
fx = function(x){(x^2) +  (54/x)}
#Aplicar el método con los parámetros mencionados
res1 = round(fibonacci(fx,a,b,N),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res2 = round(fibonacci(fx,0,10,3),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res2)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,20),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,42),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res2 = round(fibonacci(fx,0,10,3),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res2)), align = "center", part = "all"))
# Librería para hacer las tablas bonitas
library(flextable)
# Llamo el código
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
# Declaro la función que se desea minimizar
fx = function(x){(x^2) +  (54/x)}
#Aplicar el método con los parámetros mencionados
res1 = round(fibonacci(fx,0,5,3),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,50),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,5),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res3 = round(fibonacci(fx,0,5,10),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res3)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res4 = round(fibonacci(fx,0,10,20),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res4)), align = "center", part = "all"))
#Aplicar el método con los parámetros mencionados
res5 = round(fibonacci(fx,-5,0,15),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res5)), align = "center", part = "all"))
knitr::purl("Documentación.pdf","eval.r",documentation = F)
knitr::purl("Documentación.Rmd","eval.r",documentation = F)
knitr::purl("Documentación.Rmd","eval.r",documentation = F)
rm(list=ls())
source("Tarea 3. Busqueda de Fibonacci MAIN.R")
rm(list=ls())
